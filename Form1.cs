/***************************************************************************
*                                                                          *
*                      Nestor Lee (15SIS030Y / 1501044)                    *
*                        ICT 4001 - Capstone Project                       *
*                    Cryptocurrency Mining Malware Detector                *
*                    Singapore Institute of Technology (SIT)               * 
*          neslee92@gmail.com / 15SIS030Y@SIT.SingaporeTech.edu.sg         *
*                                                                          *
****************************************************************************/

/*
 * 
 *  Filename:   Form1.cs 
 *  Purpose:    Method file for the Windows Form, Form1 
 *              Contains processes for each of the items within Form1, is used to place the event handlers for the items in the Form
 *              
 */


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Net;
using System.Diagnostics;
using System.Windows.Forms;
using System.Security.Principal;
using System.Runtime.InteropServices;
using System.Net.NetworkInformation;
using System.Reflection;
using System.ServiceProcess;
using System.Management;
using CryptocurrencyMiningMalwareDectector;
using System.Text.RegularExpressions;
using System.IO;
using System.Threading;

namespace WindowsFormsAppHelloworld
{
    // Randomise process name? Gmer
    // Find ways for self-protection
    // Elevate to system level process/gain system provilege
    public partial class mainForm : Form
    {
        MachineServices machineServices = new MachineServices();

        public mainForm()
        {
            InitializeComponent();
        }


        /* Start of mainForm_load function */
        // Code added here will be executed upon the mainform being loaded and presented to the user
        private void mainForm_Load(object sender, EventArgs e)
        {            

            // Initiate how the DataGridViewColumn in the process enumeration tab is formatted
            foreach (DataGridViewColumn column in processDataTable.Columns)
            {
                column.SortMode = DataGridViewColumnSortMode.Automatic;
            }

            // Automatically start the scan for processes on the machine upon form load
            Thread threadToUpdateProcessesDataGridViewOnFirstLaunch = new Thread(new ThreadStart(scanProcessesOnMachine));
            threadToUpdateProcessesDataGridViewOnFirstLaunch.Start();

            // Automatically upate the Kernel Services DataGridView upon main form load 
            Thread threadToUpdateKernelServiceDataGridViewOnFirstLaunch = new Thread(new ThreadStart(threadUpdateDriverServicesDataGridView));
            threadToUpdateKernelServiceDataGridViewOnFirstLaunch.Start();

            // Automatically update the Non Driver Services DataGridView upon main form load
            Thread threadToUpdateNonDriverServiceDataGridViewOnFirstLaunch = new Thread(new ThreadStart(updateNonDriverServicesDataGridView));
            threadToUpdateNonDriverServiceDataGridViewOnFirstLaunch.Start();

            // Initialise the machine name
            machineName.Text = Environment.MachineName;

        }
        /* End of mainForm_load function */

        private void mainForm_Resize(object sender, EventArgs e)
        {
            if(this.WindowState == FormWindowState.Minimized)
            {
                Hide();
                cryptocurrencyMiningMalwareDetectorNotifyIcon.Visible = true;

                ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Minimised");
                ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "The Cryptocurrency Mining Malware Detector is now running in the background.");
                ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);

            }
        }

        private void mainForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            if(e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                this.WindowState = FormWindowState.Minimized;
            }
        }

        private void cryptocurrencyMiningMalwareDetectorNotifyIcon_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            Show();
            this.WindowState = FormWindowState.Normal;
            cryptocurrencyMiningMalwareDetectorNotifyIcon.Visible = false;
        }


        /* Start of menubar functions */

        // About button
        private void helpToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string versionIdentifier = "Version 1.0"; // To change to v1.0 once released
            DateTime dateOfVersionRelease = new DateTime(2018, 11, 19);

            string name = "Nestor Lee Hsien Yew";
            string matric = "15SIS030Y / 1501044";
            string university = "Singapore Institute of Technology";
            string moduleCode = "ICT 4001 Capstone Project";
            MessageBox.Show(versionIdentifier + "\n" + dateOfVersionRelease.ToString("dd MMMM yyyy") + "\n\n" + name + "\n" + matric + "\n" + university + "\n" + moduleCode, "About", MessageBoxButtons.OK, MessageBoxIcon.None);
        }

        // Exit button
        private void exitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.WindowState = FormWindowState.Minimized;
        }

        /* End of menubar functions */



        /* Start of timer function */

        // To update the Network Statistics on a 0.5second interval
        private void updateNetworkStatisticsTimer_Tick(object sender, EventArgs e)
        {
            TCPNetworkStatistics tcpNetworkStatistics = new TCPNetworkStatistics();
            TCPcurrentConnectionsValue.Text = tcpNetworkStatistics.CurrentConnections.ToString();
            TCPcumulativeConnectionsValue.Text = tcpNetworkStatistics.CumulativeConections.ToString();
            TCPinitiatedConnectionsValue.Text = tcpNetworkStatistics.InitiatedConnections.ToString();
            TCPacceptedConnectionsValue.Text = tcpNetworkStatistics.AcceptedConnections.ToString();
            TCPfailedAttemptsValue.Text = tcpNetworkStatistics.FailedConnectionAttempts.ToString();
            TCPconnectionsResetValue.Text = tcpNetworkStatistics.ConnectionsReset.ToString();

            UDPNetworkStatistics udpNetworkStatistics = new UDPNetworkStatistics();
            UDPdatagramsReceivedValue.Text = udpNetworkStatistics.DatagramsReceived.ToString();
            UDPdatagramsSentValue.Text = udpNetworkStatistics.DatagramsSent.ToString();
            UDPdatagramsDiscardedValue.Text = udpNetworkStatistics.IncomingDatagramsDiscarded.ToString();
            UDPdatagramsWithErrorsValue.Text = udpNetworkStatistics.IncomingDatagramsWithErrors.ToString();
            UDPlistenersValue.Text = udpNetworkStatistics.UDPListeners.ToString();

        }

        // To update all Services Statistics on a 0.5second interval
        private void updateServicesTimer_Tick(object sender, EventArgs e)
        {
            nonDriverRunningServicesValue.Text = machineServices.GetNonDriverRunningServicesCount().ToString();
            nonDriverStoppedServicesValue.Text = machineServices.GetNonDriverStoppedServicesCount().ToString();
            nonDriverOtherStatesValue.Text = (machineServices.GetNonDriverPausedServicesCount() + machineServices.GetNonDriverStartPendingServicesCount() +
                                                machineServices.GetNonDriverStopPendingServicesCount() + machineServices.GetNonDriverPausePendingServicesCount() +
                                                machineServices.GetNonDriverContinuePendingServicesCount()).ToString();

            driverRunningServicesValue.Text = machineServices.GetDriverRunningServicesCount().ToString();
            driverStoppedServicesValue.Text = machineServices.GetDriverStoppedServicesCount().ToString();
            driverOtherStatesValue.Text = (machineServices.GetDriverPausedServicesCount() + machineServices.GetDriverStartPendingServicesCount() +
                                            machineServices.GetDriverStopPendingServicesCount() + machineServices.GetDriverPausePendingServicesCount() +
                                            machineServices.GetDriverContinuePendingServicesCount()).ToString();
        }

        // TODO: To spawn a thread at fixed intervals used to check if there are any suspicious UDP connections 
        private void checkForSuspiciousUdpConnectionsTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToMonitorSuspiciousUDPConnections));
            thread.Start();
        }

        // TODO: To spawn a thread at fixed intervals used to check if there are any suspicious TCP connections 
        private void checkForSuspiciousTcpConnectionsTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToMonitorSuspiciousTCPConnections));
            thread.Start();
        }

        // Functions used for the checkForSuspiciousUdpConnectionsTimer_Tick & checkForSuspiciousTcpConnectionsTimer_Tick threads 
        private string GetAllConnectionsOutput()
        {
            Process p = new Process();
            ProcessStartInfo ps = new ProcessStartInfo();
            ps.Arguments = "-a -n -o";
            ps.FileName = "netstat.exe";
            ps.UseShellExecute = false;
            ps.WindowStyle = ProcessWindowStyle.Hidden;
            ps.RedirectStandardInput = true;
            ps.RedirectStandardOutput = true;
            ps.RedirectStandardError = true;
            ps.CreateNoWindow = true;

            p.StartInfo = ps;
            p.Start();

            StreamReader stdOutput = p.StandardOutput;
            StreamReader stdError = p.StandardError;

            string content = stdOutput.ReadToEnd() + stdError.ReadToEnd();
            string exitStatus = p.ExitCode.ToString();

            if (exitStatus != "0")
            {
                GetAllConnectionsOutput();
            }

            return content;
        }

        private string[] splitIPAddressAndPortNumber(string combinedIPAddressAndPortNumber)
        {
            string[] processedString = Regex.Split(combinedIPAddressAndPortNumber, "(.*)((?::))((?:[0-9]+))$");
            return processedString;
        }

        private void threadToMonitorSuspiciousUDPConnections()
        {
            Console.WriteLine("Check UDP connections thread started.");
            List<UDPPort> udpPorts = (List<UDPPort>)toGetConnectionsBasedOnProtocol("UDP");

            int suspiciousUDPConnectionsCounter = 0;
            foreach (UDPPort udpPortObj in udpPorts)
            {
                if (udpPortObj.isUDPConnectionSuspicious())
                    suspiciousUDPConnectionsCounter++;
            }
            Console.WriteLine("Number of UDP Ports Suspicious: {0}/{1}", suspiciousUDPConnectionsCounter, udpPorts.Count);
            Console.WriteLine("UDP Monitoring Thread Exit.");
            if (suspiciousUDPConnectionsCounter == 0)
            {
                ThreadHelperClass.SetText(this, suspiciousUDPConnectionsLabel, "No suspicious UDP connections found!");

                Image image = CryptocurrencyMiningMalwareDectector.Properties.Resources.imageedit_1_3877257101; // Green Tick
                ThreadHelperClass.SwapConnectionsImage(this, udpPictureBox, image);
            }
            else
            {
                ThreadHelperClass.SetText(this, suspiciousUDPConnectionsLabel, "Click on the cross to resolve!");

                Image image = CryptocurrencyMiningMalwareDectector.Properties.Resources.imageedit_1_8250390026; // Red Cross
                ThreadHelperClass.SwapConnectionsImage(this, udpPictureBox, image);
            }
        }

        private void threadToMonitorSuspiciousTCPConnections()
        {
            Console.WriteLine("Check TCP connections thread started.");
            List<TCPPort> tcpPorts = (List<TCPPort>)toGetConnectionsBasedOnProtocol("TCP");

            int suspiciousTCPConnectionsCounter = 0;
            foreach (TCPPort tcpPortObj in tcpPorts)
            {
                if (tcpPortObj.isTcpConnectionSuspicious())
                    suspiciousTCPConnectionsCounter++;
            }
            Console.WriteLine("Number of TCP Ports Suspicious: {0}/{1}", suspiciousTCPConnectionsCounter, tcpPorts.Count);
            Console.WriteLine("TCP Monitoring Thread Exit.");

            if (suspiciousTCPConnectionsCounter == 0)
            {
                ThreadHelperClass.SetText(this, suspiciousTCPConnectionsLabel, "No suspicious TCP connections found!");

                Image image = CryptocurrencyMiningMalwareDectector.Properties.Resources.imageedit_1_3877257101; // Green Tick
                ThreadHelperClass.SwapConnectionsImage(this, tcpPictureBox, image);
            }
            else
            {
                ThreadHelperClass.SetText(this, suspiciousTCPConnectionsLabel, "Click on the cross to resolve!");

                Image image = CryptocurrencyMiningMalwareDectector.Properties.Resources.imageedit_1_8250390026; // Red Cross
                ThreadHelperClass.SwapConnectionsImage(this, tcpPictureBox, image);
            }
        }

        private object toGetConnectionsBasedOnProtocol(string protocol)
        {
            if (protocol.Equals("UDP"))
            {
                List<UDPPort> udpPorts = new List<UDPPort>();
                try
                {
                    string commandOutput = GetAllConnectionsOutput();
                    string[] rows = Regex.Split(commandOutput, "\r\n");
                    foreach (string row in rows)
                    {
                        string[] tokens = Regex.Split(row, "\\s+");

                        if (tokens.Length > 4 && (tokens[1].Equals("UDP")))
                        {

                            string[] UDPlocalIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[2]);
                            IPAddress UDPlocalIP = IPAddress.Parse(UDPlocalIpPlusPortCombination[1]);
                            ushort UDPlocalPort = Convert.ToUInt16(UDPlocalIpPlusPortCombination[3]);

                            IPAddress UDPremoteIP;
                            ushort UDPremotePort;
                            string[] UDPremoteIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[3]);
                            if (UDPremoteIpPlusPortCombination[0].Equals("*:*"))
                            {
                                UDPremoteIP = null;
                                UDPremotePort = 0;
                            }
                            else
                            {
                                UDPremoteIP = IPAddress.Parse(UDPremoteIpPlusPortCombination[1]);
                                UDPremotePort = Convert.ToUInt16(UDPremoteIpPlusPortCombination[3]);
                            }
                            int UDPprocessId = Convert.ToInt32(tokens[4]);

                            udpPorts.Add(new UDPPort(UDPlocalIP, UDPlocalPort, UDPremoteIP, UDPremotePort, UDPprocessId));
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
                return udpPorts;
            }
            else if (protocol.Equals("TCP"))
            {
                List<TCPPort> tcpPorts = new List<TCPPort>();
                try
                {
                    string commandOutput = GetAllConnectionsOutput();
                    string[] rows = Regex.Split(commandOutput, "\r\n");
                    foreach (string row in rows)
                    {
                        string[] tokens = Regex.Split(row, "\\s+");

                        if (tokens.Length > 4 && (tokens[1].Equals("TCP")))
                        {
                            string[] TCPlocalIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[2]);
                            string[] TCPremoteIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[3]);
                            IPAddress TCPlocalIP = IPAddress.Parse(TCPlocalIpPlusPortCombination[1]);
                            ushort TCPlocalPort = Convert.ToUInt16(TCPlocalIpPlusPortCombination[3]);
                            IPAddress TCPremoteIP = IPAddress.Parse(TCPremoteIpPlusPortCombination[1]);
                            ushort TCPremotePort = Convert.ToUInt16(TCPremoteIpPlusPortCombination[3]);
                            string TCPtcpState = Convert.ToString(tokens[4]);
                            int TCPprocessId = Convert.ToInt32(tokens[5]);

                            tcpPorts.Add(new TCPPort(TCPlocalIP, TCPremoteIP, TCPlocalPort, TCPremotePort, TCPtcpState, TCPprocessId));
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
                return tcpPorts;
            }
            return -1;
        }

        // TODO: To spawn a thread at fixed intervals to update the Kernel Services DataGridView 
        private void updateKernelServicesTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadUpdateDriverServicesDataGridView));
            thread.Start();
        }

        private void threadUpdateDriverServicesDataGridView()
        {
            Console.WriteLine("Thread to update Kernel Service DataGridView started.");
            ServiceController[] driverScServices;
            driverScServices = ServiceController.GetDevices();

            ThreadHelperClass.CallRowsClearDataGridView(this, driverStoppedServiceDataGridView);
            ThreadHelperClass.CallRefreshDataGridView(this, driverStoppedServiceDataGridView);

            string[] suspiciousServiceNameList = { "xWinWpdSrv", "SVSHost", "Microsoft Telemetry", "lsass", "Microsoft",
                                                    "system", "Oracleupdate", "CLR", "sysmgt", "gm",
                                                    "WmdnPnSN", "Sougoudl", "Nationaaal", "Natimmonal", "Nationaloll",
                                                    "Mysa", "Mysa1", "Mysa2", "Mysa3", "ok",
                                                    "Oracle Java", "Oracle Java", "Oracle Java Update", "Spooler SubSystem Service",
                                                    "Oracle Products Reporter", "Update service for products", "gm", "ngm"
                                                  };

            for (int driverScServicesCount = 0; driverScServicesCount < driverScServices.Count(); driverScServicesCount++)
            {
                ThreadHelperClass.CallAddRowsDataGridView(this, driverStoppedServiceDataGridView);

                for (int driverStoppedServiceDataGridViewColCount = 0; driverStoppedServiceDataGridViewColCount < driverStoppedServiceDataGridView.ColumnCount; driverStoppedServiceDataGridViewColCount++)
                {
                    switch (driverStoppedServiceDataGridViewColCount)
                    {
                        case 0: // count
                            ThreadHelperClass.CallSetCellTextDataGridView(this, driverStoppedServiceDataGridView, driverScServicesCount, driverStoppedServiceDataGridViewColCount, (driverScServicesCount + 1).ToString());
                            break;
                        case 1: // service name
                            ThreadHelperClass.CallSetCellTextDataGridView(this, driverStoppedServiceDataGridView, driverScServicesCount, driverStoppedServiceDataGridViewColCount, driverScServices[driverScServicesCount].ServiceName);
                            break;
                        case 2: // status
                            ThreadHelperClass.CallSetCellTextDataGridView(this, driverStoppedServiceDataGridView, driverScServicesCount, driverStoppedServiceDataGridViewColCount, driverScServices[driverScServicesCount].Status.ToString());
                            break;
                        case 3: // is suspicious
                            // TODO: Enumerate suspicious services
                            foreach (string stringComparedTo in suspiciousServiceNameList)
                            {
                                if (stringComparedTo.Equals(driverScServices[driverScServicesCount].ServiceName, StringComparison.OrdinalIgnoreCase))
                                {
                                    ThreadHelperClass.CallSetCellTextDataGridView(this, driverStoppedServiceDataGridView, driverScServicesCount, driverStoppedServiceDataGridViewColCount, "True");
                                    break;
                                }
                                else
                                {
                                    ThreadHelperClass.CallSetCellTextDataGridView(this, driverStoppedServiceDataGridView, driverScServicesCount, driverStoppedServiceDataGridViewColCount, "False");
                                }
                            }
                            break;
                    }
                }
            }
        }

        // TODO: To spawn a thread to update the User Services DataGridView table at fixed intervals
        private void updateUserServicesTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(updateNonDriverServicesDataGridView));
            thread.Start();
        }

        private List<NonDriverServices> populateNonDriverServicesList()
        {
            List<NonDriverServices> nonDriverServicesObjList = new List<NonDriverServices>();
            ServiceController[] scServices;
            scServices = ServiceController.GetServices();

            for (int scServicesCount = 0; scServicesCount < scServices.Count(); scServicesCount++)
            {
                ManagementObject wmiService;
                wmiService = new ManagementObject("Win32_Service.Name='" + scServices[scServicesCount].ServiceName + "'");
                wmiService.Get();

                if (wmiService["Description"] != null)
                    nonDriverServicesObjList.Add(new NonDriverServices((scServicesCount + 1), scServices[scServicesCount].ServiceName, (wmiService["Description"]).ToString(),
                                                    (wmiService["State"]).ToString(), (wmiService["ProcessId"]).ToString(), scServices[scServicesCount].CanStop));
                else
                    nonDriverServicesObjList.Add(new NonDriverServices((scServicesCount + 1), scServices[scServicesCount].ServiceName, "No description found.",
                                                    (wmiService["State"]).ToString(), (wmiService["ProcessId"]).ToString(), scServices[scServicesCount].CanStop));
            }
            return nonDriverServicesObjList;
        }

        private void updateNonDriverServicesDataGridView()
        {
            ThreadHelperClass.CallRowsClearDataGridView(this, nonDriverServicesDataGridView);
            ThreadHelperClass.CallRefreshDataGridView(this, nonDriverServicesDataGridView);

            List<NonDriverServices> nonDriverServicesObjList = populateNonDriverServicesList();

            foreach (NonDriverServices nonDriverServicesObj in nonDriverServicesObjList)
            {
                ThreadHelperClass.CallAddRowsDataGridView(this, nonDriverServicesDataGridView);
                for (int nonDriverServiceDataGridViewColCount = 0; nonDriverServiceDataGridViewColCount < nonDriverServicesDataGridView.ColumnCount; nonDriverServiceDataGridViewColCount++)
                {
                    switch (nonDriverServiceDataGridViewColCount)
                    {
                        case 0: // No.
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getIndex().ToString());
                            break;
                        case 1: // Service Name
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getServiceName());
                            break;
                        case 2: // Description
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getServiceDescription());
                            break;
                        case 3: // State
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getServiceState());
                            break;
                        case 4: // PID
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getServicePID());
                            break;
                        case 5: // Can Stop?
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getCanServiceStop().ToString());
                            break;
                        case 6: // Suspicious?
                            ThreadHelperClass.CallSetCellTextDataGridView(this, nonDriverServicesDataGridView, (nonDriverServicesObj.getIndex() - 1), nonDriverServiceDataGridViewColCount, nonDriverServicesObj.getIsServiceSuspicious().ToString());
                            break;
                    }
                }
            }

        }

        // TODO: To spawn a thread at fixed intervals to update the process DataGridView
        private void updateProcessesTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(scanProcessesOnMachine));
            thread.Start();
        }

        private void scanProcessesOnMachine()
        {
            try
            {
                ThreadHelperClass.CallSetButtonText(this, performScanBtn, "Refresh");
                ThreadHelperClass.CallRowsClearDataGridView(this, processDataTable);
                ThreadHelperClass.CallRefreshDataGridView(this, processDataTable);

                /* TODO: Retrieve the list from an online repository */
                string[] suspiciousProcesses = new string[] { "notepad", "msinfo", "xmrig", "minerd", "minergate", "carbon", "yamm1", "upgeade", "auto-upgeade", "svshost",
                                                            "carss", "systemiis", "systemiissec", "windowsupdater*", "Windowsdefender*", "update", "service", "gxdrv", "lsmosee",
                                                            "csrsc", "cara", "javaupd", "gxdrv", "lsmosee"
                                                        };

                /* Get all running processes on the machine */
                Process[] allProcesses = Process.GetProcesses();

                /* Initiate the Progress Bar */
                ThreadHelperClass.CallSetProgressBarMinimumValue(this, processEnumerationProgressBar, 0);
                ThreadHelperClass.CallSetProgressBarMaximumValue(this, processEnumerationProgressBar, allProcesses.Length);
                ThreadHelperClass.CallSetProgressBarStep(this, processEnumerationProgressBar, 1);
                ThreadHelperClass.CallSetProgressBarEquals(this, processEnumerationProgressBar, 0);

                for (int noOfProcessesCounter = 0; noOfProcessesCounter < allProcesses.Length; noOfProcessesCounter++)
                {
                    ThreadHelperClass.CallAddRowsDataGridView(this, processDataTable);
                    for (int noOfColumnsCounter = 0; noOfColumnsCounter < processDataTable.Columns.Count; noOfColumnsCounter++)
                    {
                        switch (noOfColumnsCounter)
                        {
                            case 0:
                                ThreadHelperClass.CallSetCellTextDataGridView(this, processDataTable, noOfProcessesCounter, noOfColumnsCounter, (noOfProcessesCounter + 1).ToString());
                                break;
                            case 1:
                                // Process Name Column
                                ThreadHelperClass.CallSetCellTextDataGridView(this, processDataTable, noOfProcessesCounter, noOfColumnsCounter, allProcesses[noOfProcessesCounter].ProcessName);
                                break;
                            case 2:
                                // Process ID Column
                                ThreadHelperClass.CallSetCellTextDataGridView(this, processDataTable, noOfProcessesCounter, noOfColumnsCounter, allProcesses[noOfProcessesCounter].Id.ToString());
                                break;
                            case 3:
                                // Whether process is considered suspicious or not                            
                                foreach (string stringComparedTo in suspiciousProcesses)
                                {
                                    if (stringComparedTo.Equals(allProcesses[noOfProcessesCounter].ProcessName.ToString(), StringComparison.OrdinalIgnoreCase))
                                    {
                                        ThreadHelperClass.CallSetCellTextDataGridView(this, processDataTable, noOfProcessesCounter, noOfColumnsCounter, "True");
                                        break;
                                    }
                                    else
                                    {
                                        ThreadHelperClass.CallSetCellTextDataGridView(this, processDataTable, noOfProcessesCounter, noOfColumnsCounter, "False");
                                    }
                                }
                                break;
                            case 4:
                                // What if you can't kill the particular process?
                                // What if the malware is that persistant?
                                ThreadHelperClass.CallSetCellTextDataGridView(this, processDataTable, noOfProcessesCounter, noOfColumnsCounter, "Kill");
                                break;
                        }
                    }
                    ThreadHelperClass.CallSetProgressBarPerformStep(this, processEnumerationProgressBar);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        // TODO: To spawn a thread at fixed intervals to check if there are any suspicious processes to generate alerts.
        private void checkProcessAnomaliesForHeuristicsTabTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToCheckProcessAnomaliesForHeuristicsTab));
            thread.Start();
        }

        private void threadToCheckProcessAnomaliesForHeuristicsTab()
        {
            Console.WriteLine("Thread to check Process Anomalies for Heuristics Tab running.");
            try
            {
                if (processDataTable.RowCount > 0)
                {
                    for (int i = 0; i < processDataTable.RowCount; i++)
                    {
                        if (processDataTable.Rows[i].Cells[3].Value.Equals("True"))
                        {
                            ThreadHelperClass.CallCreateFlash(this);
                            ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, processOverviewTable, Color.Red);
                            ThreadHelperClass.CallSetLabelText(this, processOverviewAnomaliesFoundLabel, "True");

                            ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                            ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Process Enumeration");
                            ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Suspicious Processes found! View the Cryptocurrency Mining Malware Detector panel for more information!");
                            ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);
                            break;
                        }
                        else
                        {
                            ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, processOverviewTable, Color.LawnGreen);
                            ThreadHelperClass.CallSetLabelText(this, processOverviewAnomaliesFoundLabel, "None");
                        }

                    }
                }
            }
            catch (NullReferenceException)
            {
                Console.WriteLine("NullReferenceException caught");
            }
            catch (ArgumentOutOfRangeException)
            {
                Console.WriteLine("ArgumentOutOfRangeException caught");
            }
            catch (ArgumentException)
            {
                Console.WriteLine("ArgumentException caught");
            }
            finally
            {
                Console.WriteLine("Thread to check Process Anomalies for Heuristics Tab stopped.");
            }
        }

        // TODO: To spawn a thread at fixed intervals to check if there are any suspicious user-level services to generate alerts
        private void checkNonDriverServicesAnomaliesForHeuristicsTabTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToCheckNonDriverServiceAnomaliesForHeuristicsTab));
            thread.Start();
        }

        private void threadToCheckNonDriverServiceAnomaliesForHeuristicsTab()
        {
            Console.WriteLine("Thread to check User Service Anomalies for Heuristics Tab running.");
            try
            {
                if (nonDriverServicesDataGridView.RowCount > 0)
                {
                    Console.WriteLine("Is not 0");
                    for (int l = 0; l < nonDriverServicesDataGridView.RowCount; l++)
                    {
                        if (nonDriverServicesDataGridView.Rows[l].Cells[6].Value.Equals("True"))
                        {
                            ThreadHelperClass.CallCreateFlash(this);
                            ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, nonDriverServiceOverviewTable, Color.Red);
                            ThreadHelperClass.CallSetLabelText(this, nonDriverServiceOverviewAnomaliesFoundLabel, "True");

                            ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                            ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Service Enumeration");
                            ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Suspicious User-Level Service found! View the Cryptocurrency Mining Malware Detector panel for more information!");
                            ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);
                            break;
                        }
                        else
                        {
                            ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, nonDriverServiceOverviewTable, Color.LawnGreen);
                            ThreadHelperClass.CallSetLabelText(this, nonDriverServiceOverviewAnomaliesFoundLabel, "None");
                        }
                    }
                }
                else
                {
                    Console.WriteLine("Is 0");
                }
            }
            catch (NullReferenceException)
            {
                Console.WriteLine("NullReferenceException caught");
            }
            catch (ArgumentOutOfRangeException)
            {
                Console.WriteLine("ArgumentOutOfRangeException caught");
            }
            finally
            {
                Console.WriteLine("Thread to check User Service Anomalies for Heuristics Tab stopped.");
            }
        }

        // TODO: To spawn a thread at fixed intervals to check if there are any suspicious kernel-level services to generate alerts
        private void checkKernelDriverServicesAnomaliesForHeuristicsTabTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToCheckKernelServiceAnomaliesForHeuristicsTab));
            thread.Start();
        }

        private void threadToCheckKernelServiceAnomaliesForHeuristicsTab()
        {
            Console.WriteLine("Thread to check Kernel Service Anomalies for Heuristics Tab running.");
            try
            {
                if (driverStoppedServiceDataGridView.RowCount > 0)
                {
                    for (int l = 0; l < driverStoppedServiceDataGridView.RowCount; l++)
                    {
                        if (driverStoppedServiceDataGridView.Rows[l].Cells[3].Value.Equals("True"))
                        {
                            ThreadHelperClass.CallCreateFlash(this);
                            ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, kernelServiceOverviewTable, Color.Red);
                            ThreadHelperClass.CallSetLabelText(this, kernelServiceOverviewAnomaliesFoundLabel, "True");

                            ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                            ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Service Enumeration");
                            ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Suspicious Kernel-Level Service found! View the Cryptocurrency Mining Malware Detector panel for more information!");
                            ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);
                            break;
                        }
                        else
                        {
                            ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, kernelServiceOverviewTable, Color.LawnGreen);
                            ThreadHelperClass.CallSetLabelText(this, kernelServiceOverviewAnomaliesFoundLabel, "None");
                        }
                    }
                }
            }
            catch (NullReferenceException)
            {
                Console.WriteLine("NullReferenceException caught");
            }
            catch (ArgumentOutOfRangeException)
            {
                Console.WriteLine("ArgumentOutOfRangeException caught");
            }
            catch (ArgumentException)
            {
                Console.WriteLine("ArgumentException caught");
            }
            finally
            {
                Console.WriteLine("Thread to check Kernel Service Anomalies for Heuristics Tab stopped.");
            }
        }

        // TODO: To spawn a thread at fixed intervals to generate alerts if there are any TCP network connection anomalies found
        private void checkTCPNetworkAnomaliesForHeuristicsTabTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToCheckTCPNetworkAnomaliesForHeuristicsTab));
            thread.Start();
        }

        private void threadToCheckTCPNetworkAnomaliesForHeuristicsTab()
        {
            List<TCPPort> tcpPorts = (List<TCPPort>)toGetConnectionsBasedOnProtocol("TCP");

            int suspiciousTCPConnectionsCounter = 0;
            foreach (TCPPort tcpPortObj in tcpPorts)
            {
                if (tcpPortObj.isTcpConnectionSuspicious())
                    suspiciousTCPConnectionsCounter++;
            }
            if (suspiciousTCPConnectionsCounter == 0)
            {
                ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, tcpNetworkConnectionsOverviewTable, Color.LawnGreen);
                ThreadHelperClass.CallSetLabelText(this, tcpNetworkConnectionsOverviewAnomaliesFoundLabel, "None");
            }
            else if (suspiciousTCPConnectionsCounter > 0)
            {
                ThreadHelperClass.CallCreateFlash(this);
                ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, tcpNetworkConnectionsOverviewTable, Color.Red);
                ThreadHelperClass.CallSetLabelText(this, tcpNetworkConnectionsOverviewAnomaliesFoundLabel, "True");

                ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Network Enumeration");
                ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Suspicious TCP Connection(s) found! View the Cryptocurrency Mining Malware Detector panel for more information!");
                ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);
            }
        }

        // TODO: To spawn a thread at fixed intervals to generate alerts if there are any UDP network connection anomalies found
        private void checkUDPNetworkAnomaliesForHeuristicsTabTimer_Tick(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(threadToCheckUDPNetworkAnomaliesForHeuristicsTab));
            thread.Start();
        }

        private void threadToCheckUDPNetworkAnomaliesForHeuristicsTab()
        {
            List<UDPPort> udpPorts = (List<UDPPort>)toGetConnectionsBasedOnProtocol("UDP");

            int suspiciousUDPConnectionsCounter = 0;
            foreach (UDPPort udpPortObj in udpPorts)
            {
                if (udpPortObj.isUDPConnectionSuspicious())
                    suspiciousUDPConnectionsCounter++;
            }
            if (suspiciousUDPConnectionsCounter == 0)
            {
                ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, udpNetworkConnectionsOverviewTable, Color.LawnGreen);
                ThreadHelperClass.CallSetLabelText(this, udpNetworkConnectionsOverviewAnomaliesFoundLabel, "None");
            }
            else if (suspiciousUDPConnectionsCounter > 0)
            {
                ThreadHelperClass.CallCreateFlash(this);
                ThreadHelperClass.CallSetTableLayoutBackgroundColor(this, udpNetworkConnectionsOverviewTable, Color.Red);
                ThreadHelperClass.CallSetLabelText(this, udpNetworkConnectionsOverviewAnomaliesFoundLabel, "True");

                ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Network Enumeration");
                ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "Suspicious UDP Connection(s) found! View the Cryptocurrency Mining Malware Detector panel for more information!");
                ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);
            }
        }


        /* End of timer function */



        /* Start of tooltip functions */
        // Code here are to show tooltips for short descriptions on what each field may specify/mean

        private void nonDriverOtherStatesLabel_MouseHover(object sender, EventArgs e)
        {
            ToolTip currentConnectionsToolTip = new ToolTip();
            currentConnectionsToolTip.SetToolTip(this.nonDriverOtherStatesLabel, "Can include Paused, Start Pending, Stop Pending, Pause Pending, Continue Pending.");
        }

        private void driverOtherStatesLabel_MouseHover(object sender, EventArgs e)
        {
            ToolTip currentConnectionsToolTip = new ToolTip();
            currentConnectionsToolTip.SetToolTip(this.driverOtherStatesLabel, "Can include Paused, Start Pending, Stop Pending, Pause Pending, Continue Pending.");
        }




        /* Start of code block for functions in the process enumeration tab */


        // Refresh DataGridView
        private void performScanBtn_Click(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(scanProcessesOnMachine));
            thread.Start();
        }

        /* Function to kill a partiucular process from the PID */
        private void processDataTable_CellContentClick(object sender, DataGridViewCellEventArgs e)
        {
            var senderGrid = (DataGridView)sender;
            if (senderGrid.Columns[e.ColumnIndex] is DataGridViewButtonColumn && e.RowIndex >= 0)
            {
                if (processDataTable.Rows[e.RowIndex].Cells[3].Value.ToString().Equals("False"))
                {
                    var confirmIfWantToKillNotSuspiciousProcessMessageBuilder = "Process is not deemed suspicious! Are you sure you want to continue?";
                    var confirmContinueNotSuspiciousResult = MessageBox.Show(confirmIfWantToKillNotSuspiciousProcessMessageBuilder, "Confirmation", MessageBoxButtons.YesNo);
                    if (confirmContinueNotSuspiciousResult == DialogResult.Yes)
                    {
                        int pidToKill = Convert.ToInt32(processDataTable.Rows[e.RowIndex].Cells[2].Value.ToString());
                        killProcessByPID(pidToKill);
                    }
                }
                else if (processDataTable.Rows[e.RowIndex].Cells[3].Value.ToString().Equals("True"))
                {
                    int pidToKill = Convert.ToInt32(processDataTable.Rows[e.RowIndex].Cells[2].Value.ToString());
                    killProcessByPID(pidToKill);
                }
            }
        }

        private void killProcessByPID(int pid)
        {
            try
            {
                Process p = Process.GetProcessById(pid);
                string stringToDisplayBuilder = "Are you sure you want to stop this process?" + "\nProcess Name: " + p.ProcessName + "\nProcess ID: " + p.Id + "\n";
                var confirmResult = MessageBox.Show(stringToDisplayBuilder, "Confirmation", MessageBoxButtons.YesNo);
                if (confirmResult == DialogResult.Yes)
                {
                    p.Kill();
                    scanProcessesOnMachine();
                }
            }
            catch (ArgumentException)
            {
                MessageBox.Show("Process is no longer running.");
            }
        }
        /* End of code block for functions in the process enumeration tab */





        /* Start of code block for functions in the service enumeration tab */

        // Spawn a thread at when the user clicks on the "Kill all suspicious user-level services" button
        private void stopSuspiciousNonDriverServicesBtn_Click(object sender, EventArgs e)
        {
            Thread thread = new Thread(new ThreadStart(gatherSuspiciousNonDriverServices));
            thread.Start();
        }

        private void gatherSuspiciousNonDriverServices()
        {
            List<string> pidToKill = new List<string>();
            try
            {
                if (nonDriverServicesDataGridView.RowCount > 0)
                {
                    for (int l = 0; l < nonDriverServicesDataGridView.RowCount; l++)
                    {
                        if (nonDriverServicesDataGridView.Rows[l].Cells[6].Value.Equals("True"))
                        {
                            pidToKill.Add(nonDriverServicesDataGridView.Rows[l].Cells[1].Value.ToString());
                        }
                    }
                    if (pidToKill.Count == 0)
                    {
                        MessageBox.Show("No suspicious processes found!");
                    }
                    else
                    {
                        string stringBuilderForMessageBox = "Are you sure you want to kill all suspicious user-level services?";
                        var confirmResult = MessageBox.Show(stringBuilderForMessageBox, "Stop Services", MessageBoxButtons.YesNo);
                        if (confirmResult == DialogResult.Yes)
                        {
                            foreach (string token in pidToKill)
                            {
                                ServiceController service = new ServiceController(token);
                                service.Stop();
                                var timeout = new TimeSpan(0, 0, 5);
                                service.WaitForStatus(ServiceControllerStatus.Stopped, timeout);
                            }
                        }
                    }
                }
                else if (nonDriverServicesDataGridView.RowCount == 0)
                {
                    MessageBox.Show("Please wait for the table to be updated.", "Stop Services");
                }
            }
            catch (NullReferenceException)
            {
                Console.WriteLine("NullReferenceException caught");
            }
            catch (ArgumentOutOfRangeException)
            {
                Console.WriteLine("ArgumentOutOfRangeException caught");
            }
        }

        // Click on Kernel Services Infomation icon
        private void kernelServiceInformationPictureBox_Click(object sender, EventArgs e)
        {
            MessageBox.Show("Kernel Services are routines that provide runtime kernel environments to programs executing in kernel mode. " +
                "As such, they cannot be stopped gracefully, as it will cause a Blue-Screen-of-Death (BSOD). " +
                "To remove such services, it is recommended to perform a system wipe and to install the latest version of Windows.", "Information");
        }

        private void kernelServiceInformationPictureBox_MouseEnter(object sender, EventArgs e)
        {
            udpPictureBox.Cursor = Cursors.Hand;
        }

        private void kernelServiceInformationPictureBox_MouseLeave(object sender, EventArgs e)
        {
            udpPictureBox.Cursor = Cursors.Default;
        }

        /* End of code block for functions in the service enumeration tab */





        /* Start of code block for functions in the network enumeration tab */

        private void tcpNetworkConnectionsBtn_Click(object sender, EventArgs e)
        {
            Console.WriteLine("View TCP Connections clicked.");
            Form2 f2 = new Form2();
            if (Application.OpenForms[f2.Name] == null)
            {
                f2.Show();
            }
            else
            {
                Application.OpenForms[f2.Name].Focus();
            }
        }

        private void udpNetworkConnectionsBtn_Click(object sender, EventArgs e)
        {
            Console.WriteLine("View UDP Connections clicked.");
            Form f3 = new Form3();
            if (Application.OpenForms[f3.Name] == null)
            {
                f3.Show();
            }
            else
            {
                Application.OpenForms[f3.Name].Focus();
            }
        }

        // TCP Suspicious Tick/Cross box
        private void pictureBox1_Click(object sender, EventArgs e)
        {
            Console.WriteLine("TCP Checkbox clicked.");
            List<TCPPort> tcpPorts = new List<TCPPort>();
            int tcpConnectionCount = 0;

            try
            {
                string commandOutput = GetAllConnectionsOutput();
                string[] rows = Regex.Split(commandOutput, "\r\n");
                foreach (string row in rows)
                {
                    string[] tokens = Regex.Split(row, "\\s+");

                    if (tokens.Length > 4 && (tokens[1].Equals("TCP")))
                    {
                        tcpConnectionCount++;

                        string[] TCPlocalIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[2]);
                        string[] TCPremoteIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[3]);
                        IPAddress TCPlocalIP = IPAddress.Parse(TCPlocalIpPlusPortCombination[1]);
                        ushort TCPlocalPort = Convert.ToUInt16(TCPlocalIpPlusPortCombination[3]);
                        IPAddress TCPremoteIP = IPAddress.Parse(TCPremoteIpPlusPortCombination[1]);
                        ushort TCPremotePort = Convert.ToUInt16(TCPremoteIpPlusPortCombination[3]);
                        string TCPtcpState = Convert.ToString(tokens[4]);
                        int TCPprocessId = Convert.ToInt32(tokens[5]);

                        tcpPorts.Add(new TCPPort(TCPlocalIP, TCPremoteIP, TCPlocalPort, TCPremotePort, TCPtcpState, TCPprocessId));
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            List<int> processIDsWhichHaveSuspiciousTCPConnections = new List<int>();
            foreach (TCPPort tcpPortObj in tcpPorts)
            {
                if (tcpPortObj.isTcpConnectionSuspicious())
                    processIDsWhichHaveSuspiciousTCPConnections.Add(tcpPortObj.getProcessId());
            }
            if (processIDsWhichHaveSuspiciousTCPConnections.Count == 0)
            {
                MessageBox.Show("No suspicious TCP connections found!");
            }
            else
            {
                string stringToDisplayBuilder = "Are you sure you want to stop the following process(es)?\n\n";
                foreach (int tcpPid in processIDsWhichHaveSuspiciousTCPConnections)
                {
                    stringToDisplayBuilder += (tcpPid.ToString() + ", ");
                }
                var confirmResult = MessageBox.Show(stringToDisplayBuilder, "Confirmation", MessageBoxButtons.YesNo);
                if (confirmResult == DialogResult.Yes)
                {
                    foreach (int tcpPidToKill in processIDsWhichHaveSuspiciousTCPConnections)
                    {
                        killProcessByPID(tcpPidToKill);
                        // Process p = Process.GetProcessById(tcpPidToKill);
                        // p.Kill();
                    }
                }
            }
        }

        // UDP Suspicious Tick/Cross box
        private void pictureBox2_Click(object sender, EventArgs e)
        {
            Console.WriteLine("UDP Checkbox clicked.");
            List<UDPPort> udpPorts = new List<UDPPort>();
            int udpConnectionCount = 0;

            try
            {
                string commandOutput = GetAllConnectionsOutput();
                string[] rows = Regex.Split(commandOutput, "\r\n");
                foreach (string row in rows)
                {
                    string[] tokens = Regex.Split(row, "\\s+");

                    if (tokens.Length > 4 && (tokens[1].Equals("UDP")))
                    {
                        udpConnectionCount++;

                        string[] UDPlocalIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[2]);
                        IPAddress UDPlocalIP = IPAddress.Parse(UDPlocalIpPlusPortCombination[1]);
                        ushort UDPlocalPort = Convert.ToUInt16(UDPlocalIpPlusPortCombination[3]);

                        IPAddress UDPremoteIP;
                        ushort UDPremotePort;
                        string[] UDPremoteIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[3]);
                        if (UDPremoteIpPlusPortCombination[0].Equals("*:*"))
                        {
                            UDPremoteIP = null;
                            UDPremotePort = 0;
                        }
                        else
                        {
                            UDPremoteIP = IPAddress.Parse(UDPremoteIpPlusPortCombination[1]);
                            UDPremotePort = Convert.ToUInt16(UDPremoteIpPlusPortCombination[3]);
                        }
                        int UDPprocessId = Convert.ToInt32(tokens[4]);

                        udpPorts.Add(new UDPPort(UDPlocalIP, UDPlocalPort, UDPremoteIP, UDPremotePort, UDPprocessId));
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            List<int> processIDsWhichHaveSuspiciousUDPConnections = new List<int>();
            foreach (UDPPort udpPortObj in udpPorts)
            {
                if (udpPortObj.isUDPConnectionSuspicious())
                    processIDsWhichHaveSuspiciousUDPConnections.Add(udpPortObj.getProcessId());
            }
            if (processIDsWhichHaveSuspiciousUDPConnections.Count == 0)
            {
                MessageBox.Show("No suspicious UDP connections found!");
            }
            else
            {
                string stringToDisplayBuilder = "Are you sure you want to stop the following process(es)?\n\n";
                foreach (int udpPid in processIDsWhichHaveSuspiciousUDPConnections)
                {
                    stringToDisplayBuilder += (udpPid.ToString() + ", ");
                }
                var confirmResult = MessageBox.Show(stringToDisplayBuilder, "Confirmation", MessageBoxButtons.YesNo);
                if (confirmResult == DialogResult.Yes)
                {
                    foreach (int udpPidToKill in processIDsWhichHaveSuspiciousUDPConnections)
                    {
                        killProcessByPID(udpPidToKill);
                        // Process p = Process.GetProcessById(udpPidToKill);
                        // p.Kill();
                    }
                }
            }
        }

        private void tcpPictureBox_MouseEnter(object sender, EventArgs e)
        {
            tcpPictureBox.Cursor = Cursors.Hand;
        }

        private void tcpPictureBox_MouseLeave(object sender, EventArgs e)
        {
            tcpPictureBox.Cursor = Cursors.Default;
        }

        private void udpPictureBox_MouseEnter(object sender, EventArgs e)
        {
            udpPictureBox.Cursor = Cursors.Hand;
        }

        private void udpPictureBox_MouseLeave(object sender, EventArgs e)
        {
            udpPictureBox.Cursor = Cursors.Default;
        }

        /* End of code block for functions in the network enumeration tab */




        /* Start of code block for Heuristics Tab */
        private void goToProcessTabBtn_Click(object sender, EventArgs e)
        {
            tabControl1.SelectedTab = processTab;
        }

        private void goToServiceTabBtn_Click(object sender, EventArgs e)
        {
            tabControl1.SelectedTab = serviceTab;
        }

        private void goToNetworkTabBtn_Click(object sender, EventArgs e)
        {
            tabControl1.SelectedTab = networkTab;
        }

        private void retrieveCPURAMUtilisationTimer_Tick(object sender, EventArgs e)
        {
            // Init the Progress Bar to check for utilisation
            Thread threadToPrintCPUutilisation = new Thread(new ThreadStart(printCPUutilisation));
            threadToPrintCPUutilisation.Start();
        }

        private void printCPUutilisation()
        {

            float cpuUtilisation = getCPUCounter();
            float ramUtilisation = getRAMCounter();

            ThreadHelperClass.CallSetProgressBarValue(this, cpuUtilisationProgressBar, (int)cpuUtilisation);
            ThreadHelperClass.CallSetLabelText(this, cpuUtilisationLabel, string.Format("{0:0.00}%", getCPUCounter()));

            ThreadHelperClass.CallSetProgressBarValue(this, ramUtilisationProgressBar, (int)ramUtilisation);
            ThreadHelperClass.CallSetLabelText(this, ramUtilisationLabel, string.Format("{0:0.00}%", getRAMCounter()));

            
        }

        public float getCPUCounter()
        {
            PerformanceCounter cpuCounter = new PerformanceCounter();
            cpuCounter.CategoryName = "Processor";
            cpuCounter.CounterName = "% Processor Time";
            cpuCounter.InstanceName = "_Total";

            // will always start at 0
            float firstValue = cpuCounter.NextValue();
            System.Threading.Thread.Sleep(1000);
            // now matches task manager reading
            float secondValue = cpuCounter.NextValue();

            return secondValue;
        }

        public float getRAMCounter()
        {
            PerformanceCounter ramCounter = new PerformanceCounter();
            ramCounter.CategoryName = "Memory";
            ramCounter.CounterName = "% Committed Bytes In Use";

            float firstValue = ramCounter.NextValue();
            System.Threading.Thread.Sleep(1000);
            // now matches task manager reading
            float secondValue = ramCounter.NextValue();

            return secondValue;
        }

        static int totalHits = 0;
        private void checkCPUUtilisationTimer_Tick(object sender, EventArgs e)
        {
            Thread threadToCheckCPUUtilisation = new Thread(new ThreadStart(functionToCheckCPUUtilisation));
            threadToCheckCPUUtilisation.Start();
            
        }

        private void functionToCheckCPUUtilisation()
        {
            if (getCPUCounter() >= 90)
            {
                totalHits = totalHits + 1;
                if (totalHits == 60)
                {
                    Image image = CryptocurrencyMiningMalwareDectector.Properties.Resources.imageedit_1_8250390026; // Red Cross
                    ThreadHelperClass.CallCreateFlash(this);
                    ThreadHelperClass.CallSetLabelText(this, cpuRamUtilisationOverviewLabel, "Please determine RCA of spike in CPU Utilisation!");
                    ThreadHelperClass.SwapConnectionsImage(this, cpuRamUtilisationOverviewPictureBox, image);
                    // MessageBox.Show("ALERT 90% usage for 1 minute! Please perform an anti-virus scan to ensure that the machine is free of Cryptominers.");

                    ThreadHelperClass.CallSetBalloonTipIcon(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, ToolTipIcon.Info);
                    ThreadHelperClass.CallSetBalloonTipTitle(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "CPU Utilisation");
                    ThreadHelperClass.CallSetBalloonTipText(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, "90% CPU Utilisation over 60 seconds! Please perform manual verification on machine to determine machine is free of Cryptominers!");
                    ThreadHelperClass.CallShowBalloonTip(this, cryptocurrencyMiningMalwareDetectorNotifyIcon, 3000);

                    totalHits = 0;
                }
            }
            else
            {
                totalHits = 0;
            }

            Console.WriteLine("After loop, totalHits = {0}", totalHits);
        }

        






        /* End of code block for Heuristics Tab */

    }
}
