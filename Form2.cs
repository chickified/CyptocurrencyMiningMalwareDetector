/***************************************************************************
*                                                                          *
*                      Nestor Lee (15SIS030Y / 1501044)                    *
*                        ICT 4001 - Capstone Project                       *
*                    Cryptocurrency Mining Malware Detector                *
*                    Singapore Institute of Technology (SIT)               * 
*          neslee92@gmail.com / 15SIS030Y@SIT.SingaporeTech.edu.sg         *
*                                                                          *
****************************************************************************/

/*
 * 
 *  Filename:   Form2.cs 
 *  Purpose:    Method file for the Windows Form, Form2 
 *              Contains processes for each of the items within Form2, is used to place the event handlers for the items in the Form
 *              
 */


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using WindowsFormsAppHelloworld;

namespace CryptocurrencyMiningMalwareDectector
{
    public partial class Form2 : Form
    {
        public Form2()
        {
            InitializeComponent();
        }

        private string GetAllConnectionsOutput()
        {
            Process p = new Process();
            ProcessStartInfo ps = new ProcessStartInfo();
            ps.Arguments = "-a -n -o";
            ps.FileName = "netstat.exe";
            ps.UseShellExecute = false;
            ps.WindowStyle = ProcessWindowStyle.Hidden;
            ps.RedirectStandardInput = true;
            ps.RedirectStandardOutput = true;
            ps.RedirectStandardError = true;
            ps.CreateNoWindow = true;

            p.StartInfo = ps;
            p.Start();

            StreamReader stdOutput = p.StandardOutput;
            StreamReader stdError = p.StandardError;

            string content = stdOutput.ReadToEnd() + stdError.ReadToEnd();
            string exitStatus = p.ExitCode.ToString();

            if (exitStatus != "0")
            {
                GetAllConnectionsOutput();
            }

            return content;
        }

        private string[] splitIPAddressAndPortNumber(string combinedIPAddressAndPortNumber)
        {
            // Index 0 = empty space
            // Index 1 = IP Address
            // Index 2 = Colon
            // Index 3 = Port Number
            string[] processedString = Regex.Split(combinedIPAddressAndPortNumber, "(.*)((?::))((?:[0-9]+))$");            
            return processedString;
        }

        private void tcpConnectionsForm_Load(object sender, EventArgs e)
        {
            executeCommandsToGetTcpConnections();
        }

        private List<TCPPort> executeCommandsToGetTcpConnections()
        {
            List<TCPPort> tcpPorts = new List<TCPPort>();
            int tcpConnectionCount = 0;
            try
            {
                string commandOutput = GetAllConnectionsOutput();
                string[] rows = Regex.Split(commandOutput, "\r\n");
                foreach (string row in rows)
                {
                    string[] tokens = Regex.Split(row, "\\s+");

                    if (tokens.Length > 4 && (tokens[1].Equals("TCP")))
                    {
                        tcpConnectionCount++;
                        // tokens[0] = empty space
                        // tokens[1] = protocol (tcp/udp)
                        // tokens[2] = local ip + local port
                        // tokens[3] = remote ip + remote port
                        // tokens[4] = TCP state
                        // tokens[5] = process id

                        string[] TCPlocalIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[2]);
                        string[] TCPremoteIpPlusPortCombination = splitIPAddressAndPortNumber(tokens[3]);
                        IPAddress TCPlocalIP = IPAddress.Parse(TCPlocalIpPlusPortCombination[1]);
                        ushort TCPlocalPort = Convert.ToUInt16(TCPlocalIpPlusPortCombination[3]);
                        IPAddress TCPremoteIP = IPAddress.Parse(TCPremoteIpPlusPortCombination[1]);
                        ushort TCPremotePort = Convert.ToUInt16(TCPremoteIpPlusPortCombination[3]);
                        string TCPtcpState = Convert.ToString(tokens[4]);
                        int TCPprocessId = Convert.ToInt32(tokens[5]);

                        tcpPorts.Add(new TCPPort(TCPlocalIP, TCPremoteIP, TCPlocalPort, TCPremotePort, TCPtcpState, TCPprocessId));
                    }                    
                }
                populateTcpNetworkInformationTable(tcpPorts);                
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            tcpFormTotalConnectionsValue.Text = tcpPorts.Count.ToString();
            return tcpPorts;
        }

        private void populateTcpNetworkInformationTable(List<TCPPort> tcpPorts)
        {

            tcpNetworkInformationTable.Rows.Clear();
            tcpNetworkInformationTable.Refresh();
            for(int listCount = 0; listCount < tcpPorts.Count; listCount++)
            {
                tcpNetworkInformationTable.Rows.Add();
                for(int columnCount = 0; columnCount < tcpNetworkInformationTable.ColumnCount; columnCount++)
                {
                    switch (columnCount)
                    {
                        case 0: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = (listCount + 1).ToString();
                                break;
                        case 1: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getLocalAddress();
                                break;
                        case 2: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getLocalPort();
                                break;
                        case 3: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getRemoteAddress();
                                break;
                        case 4: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getRemotePort();
                                break;
                        case 5: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getTcpState();
                                break;
                        case 6: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getProcessName();
                                break;                      
                        case 7: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].getProcessId();
                                break;
                        case 8: tcpNetworkInformationTable.Rows[listCount].Cells[columnCount].Value = tcpPorts[listCount].isTcpConnectionSuspicious();
                                break;
                    }
                }
            }
            tcpNetworkInformationTable.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.Fill;

        }

        private void timer1_Tick(object sender, EventArgs e)
        {
            // TCPNetworkStatistics tcpNetworkStatistics = new TCPNetworkStatistics();
            // tcpFormTotalConnectionsValue.Text = tcpNetworkStatistics.CumulativeConections.ToString();
        }

        private void refreshTcpConnectionsButton_Click(object sender, EventArgs e)
        {
            executeCommandsToGetTcpConnections();
        }
    }
}
